###!! BASIC SETTINGS !!###
set ifs "\n"
set shell bash
set shellopts '-eu'

# UI
#set hidden true
set icons true
set drawbox
set scrolloff 10
set truncatechar "â€¦"
set tabstop 4
set scrolloff 5
set wrapscroll
set period 1

# Search
set ignorecase true
set globsearch true
set incsearch true
set findlen 0

# Previews
set previewer ~/.config/lf/previewer/preview
set cleaner ~/.config/lf/previewer/clean
map i $LESSOPEN='| ~/.config/lf/previeuer/scope-wrapper.sh %s' less -R $f

# Remove some defaults
map m
map t
map "'"
map '"'
map w
map d
map r
#======

###!! CUSTOM FUNCTIONS !!###
cmd on-select &{{
    lf -remote "send $id set statfmt \"$(eza -ldg --color=always "$f")\""
}}

### SEARCH ###
cmd fzf_jump ${{
    res="$(fd . -d 1 -H | fzf --reverse --header='Jump to location' | sed 's/\\/\\\\/g;s/"/\\"/g')"
    if [ -d "$res" ] ; then
        cmd="select"
    elif [ -f "$res" ] ; then
        cmd="select"
    else
        exit 0
    fi
    lf -remote "send $id $cmd \"$res\""
}}
map / :fzf_jump

cmd fzf_search ${{
    RG_PREFIX="rg --column --line-number --no-heading --color=always --smart-case "
    res="$(
        FZF_DEFAULT_COMMAND="$RG_PREFIX ''" \
            fzf --bind "change:reload:$RG_PREFIX {q} || true" \
            --ansi --layout=reverse --header 'Search in files' \
            | cut -d':' -f1 | sed 's/\\/\\\\/g;s/"/\\"/g'
    )"
    [ -n "$res" ] && lf -remote "send $id select \"$res\""
}}

map <c-f> :fzf_search
#---

### OPEN ###
#cmd open &~/.config/lf/lf_open "$f"
cmd open $set -f; rifle -p 0 "$fx"

#cmd open-with-gui &$@ $fx ## opens with a gui application outside lf client
#cmd open-with-cli $$@ $fx ## opens with a cli application inside lf client

cmd open-with ${{
    clear
    set -f
    rifle -l $fx | sed -e "s/:[a-Z]*:[a-Z]*:/ \| /"
    read -p "open with: " method
    rifle -p $method $fx
}}
#---

### MAKE STUFF ###
cmd mkdir %{{
    printf "Directory Name: "
    read -r dir

    while [ -z "$dir" ];
    do
        read -r dir

        if [ -z "$dir" ]; then
            printf "Directory Name: "
        fi
    done

    if [ -d "$dir" ]; then
        lf -remote "send $id cd \"$dir\""
    else
        mkdir -m 775 "$dir"
        lf -remote "send $id select \"$dir\""
    fi
}}

cmd mkfile %{{
    mode="$1"
    printf "File Name: "
    read -r file

    while [ -z "$file" ];
    do
        read -r file

        if [ -z "$file" ]; then
            printf "File Name: "
        fi
    done

    if [ -e "$file" ]; then
        lf -remote "send $id \$$EDITOR \"$file\""
    else
        case $mode in
            normal)
                touch "$file"
                lf -remote "send $id \$$EDITOR \"$file\""
                ;;
            script)
                echo "#!/bin/sh" >> "$file"
                chmod +x "$file"
                lf -remote "send $id \$$EDITOR \"$file\""
                ;;
        esac
    fi
}}

cmd chmod %{{
    mode="$1"
    printf "Mode Bits: "
    read -r bits

    case $mode in
        files)
            for file in $fx
            do
                chmod "$bits" "$file"
            done
            ;;
        dir-recurs)
            for dir in $fx
            do
                chmod -R "$bits" "$dir"
            done
            ;;
    esac
    lf -remote 'send reload'
}}
#---

### RENAME ### 
cmd bulkrename ${{
    vimv -- $(basename -a -- $fx)

    lf -remote "send $id load"
    lf -remote "send $id unselect"
}}

map R bulkrename

# Better Rename
map ri rename
map rI :rename; cmd-home
map rA :rename; cmd-end
map rc :rename; cmd-delete-home
map rC :rename; cmd-end; cmd-delete-home
#---

### COPY & PASTE COMMANDS ###
cmd paste-override &{{
    set -f
    mode=$(head -1 ~/.local/share/lf/files)
    list=$(sed 1d ~/.local/share/lf/files)
    set -- _ $list; shift
    [ $# -gt 0 ] || exit
    case $mode in
        copy)
            rsync -r "$@" ./
            ;;
        move)
            rsync -r --remove-source-files "$@" ./
            ;;
    esac
    lf -remote 'save\nmove\n'
    lf -remote "send $id load"
    lf -remote "send $id echo \"\033[0;32mpasted $# file(s)\033[0m\""
}}

# Make links
# y (select for copy) and Pl to paste soft-link
# x (select for cut) and Pl to paste hard-link
cmd link %{{
    set -- $(cat ~/.local/share/lf/files)
    mode="$1"
    shift
    if [ "$#" -lt 1 ]; then
        lf -remote "send $id echo no files to link"
        exit 0
    fi
    case "$mode" in
        # symbolically copy mode is indicating a soft link
        copy) ln -sr -t . -- "$@";;
        # while a move mode is indicating a hard link
        move) ln -t . -- "$@";;
    esac
    rm ~/.local/share/lf/files
    lf -remote "send clear"
}}

cmd follow_link %{{
    lf -remote "send ${id} select '$(readlink $f)'"
}}

# Copy directory names
cmd yank-dirname $dirname -- "$f" | head -c-1 | xclip -i -selection clipboard
cmd yank-path $printf '%s' "$fx" | xclip -i -selection clipboard
cmd yank-basename $basename -a -- $fx | head -c-1 | xclip -i -selection clipboard
cmd yank-basename-without-extension &basename -a -- $fx | cut -d. -f1 | head -c-1 | xclip -i -selection clipboard

# Dragon-drop
cmd dragon %dragon-drop -a -x $fx
cmd dragon-stay %dragon-drop -a $fx
cmd dragon-individual %dragon-drop $fx
cmd dlfile %dlfile
#---

### ARCHIVE BINDINGS ###
# extract the current file with the right command
cmd unarchive ${{
    set -f
    dir="${f%%.*}"
    if [ ! -d "$dir" ]; then
        mkdir "$dir"
    fi

    case "$f" in
        *.tar.bz|*.tar.bz2|*.tbz|*.tbz2) tar xjvf "$f" -C "$dir";;
        *.tar.gz|*.tgz) tar xzvf "$f" -C "$dir";;
        *.tar.xz|*.txz) tar xJvf "$f" -C "$dir";;
        *.zip) unzip "$f" -d "$dir";;
        *.rar) unrar x "$f" "$dir";;
        *.7z) 7z x "$f" -o"$dir";;
        *) echo "Unsupported format";;
    esac
}}

# tar and bzip2
cmd tarbz2 %{{
    set -f
    printf "Archive name: "
    read -r name

    if [ ! -d "$name" ]; then
        mkdir "$name"
    fi

    cp -r $fx "$name"
    tar -cvjf "$name".tar.bz2 "$name"
    rm -rf "$name"
}}

# tar only
cmd tar %{{
    set -f
    printf "Archive name: "
    read -r name

    if [ ! -d "$name" ]; then
        mkdir "$name"
    fi

    cp -r $fx "$name"
    tar -cvf "$name".tar "$name"
    rm -rf "$name"
}}

# tar and gunzip
cmd targz %{{
    set -f
    printf "Archive name: "
    read -r name

    if [ ! -d "$name" ]; then
        mkdir "$name"
    fi

    cp -r $fx "$name"
    tar -cvzf "$name".tar.gz "$name"
    rm -rf "$name"
}}

# zip
cmd zip %{{
    set -f
    printf "Archive name: "
    read -r name

    if [ ! -d "$name" ]; then
        mkdir "$name"
    fi

    cp -r $fx "$name"
    zip -r "$name".zip "$name"
    rm -rf "$name"
}}
#---

### TRASH BINDINGS ###
cmd trash ${{
    files=$(printf "$fx" | tr '\n' ';')
    while [ "$files" ]; do
        # extract the substring from start of string up to delimiter.
        # this is the first "element" of the string.
        file=${files%%;*}

        trash-put "$(basename "$file")"
        # if there's only one element left, set `files` to an empty string.
        # this causes us to exit this `while` loop.
        # else, we delete the first "element" of the string from files, and move onto the next.
        if [ "$files" = "$file" ]; then
            files=''
        else
            files="${files#*;}"
        fi
    done
}}

cmd clear_trash !trash-empty

cmd restore_trash !trash-restore
#---

### CD ###
# LFCD
cmd quit-and-cd &{{
    pwd > "$LF_CD_FILE"
    lf -remote "send $id quit"
}}

map Q quit-and-cd
#---

# zoxide
cmd z %{{
    result="$(zoxide query --exclude $PWD $@ | sed 's/\\/\\\\/g;s/"/\\"/g')"
    lf -remote "send $id cd \"$result\""
}}

cmd zi ${{
    result="$(zoxide query -i | sed 's/\\/\\\\/g;s/"/\\"/g')"
    lf -remote "send $id cd \"$result\""
}}

cmd on-cd &{{
    zoxide add "$PWD"
}}
#---
#======

###!! BINDINGS !!###
# Basic Functions
map . set hidden!
map p paste
map x cut
map DD delete
map mf mkfile normal
map ms mkfile script
map md mkdir
map mx. chmod files
map mxr chmod dir-recurs
map bg $cutebg $f
#map O push :open-with-gui<space> ## input application
#map o push :open-with-cli<space> ## input application
map o open-with
map <enter> open
map <delete> delete

# Archive mappings
map au unarchive
map at tar
map ag targz
map ab tarbz2
map az zip

# Trash Mappings
map dd trash
map tr restore_trash
map tc clear_trash

# Copy and paste
map Po paste-override
map Pl :link
map Yd yank-dirname
map Yp yank-path
map Yn yank-basename
map Yw yank-basename-without-extension

# Dragon mapping
map dr dragon
map ds dragon-stay
map di dragon-individual
map dl dlfile

### MOVEMENT ###
# User directories
map gd cd ~/Downloads
map gD. cd ~/Documents
map gDi cd ~/Documents/IRL
map gDe cd ~/Documents/IRL/Escuela
map gDp cd ~/Documents/PDF
map gp. cd ~/Pictures
map gpw cd ~/Pictures/Wallpapers/
map gv cd ~/Videos
map gm cd ~/Music
map gM cd /data
map gS cd ~/.local/share/
map gu cd /run/media/migu
map gG cd ~/Games

# Coding
map C cd ~/.config/lf/
map gc cd ~/.config
map gC cd ~/codino
map gr cd ~/repos
map gl cd ~/.local
map gs cd ~/.local/bin

# Root directories
map gR cd /
map gU. cd /usr
map gUs cd /usr/share
map gE cd /etc

map gL follow_link
map gt. cd ~/.local/share/Trash/files
map gtd cd /data/.Trash-1000/files

map J :updir; set dironly true; down; set dironly false; open
map K :updir; set dironly true; up; set dironly false; open
#---
#======
